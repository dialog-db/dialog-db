//! Typesafe builder for [`Delegation`].

use super::policy::predicate::Predicate;
use crate::{
    command::Command,
    crypto::nonce::Nonce,
    envelope::{Envelope, EnvelopePayload},
    issuer::Issuer,
    sealed::{CommandOrUnset, DidOrUnset, IssuerOrUnset, SubjectOrUnset},
    subject::Subject,
    time::timestamp::Timestamp,
    unset::Unset,
};
use ipld_core::ipld::Ipld;
use std::{collections::BTreeMap, marker::PhantomData};
use varsig::{Did, Principal, Signature};

/// Typesafe builder for [`Delegation`][super::Delegation].
///
/// `S` is the signature type. Type parameters track which required
/// fields have been set; call `.try_build()` once all are provided.
#[derive(Default, Debug, Clone)]
pub struct DelegationBuilder<
    S: Signature,
    Iss: IssuerOrUnset<S> = Unset,
    Audience: DidOrUnset = Unset,
    Sub: SubjectOrUnset = Unset,
    Cmd: CommandOrUnset = Unset,
> {
    /// Issuer of the delegation.
    pub issuer: Iss,

    /// Audience of the delegation.
    pub audience: Audience,

    /// Subject of the delegation (the resource or object being accessed).
    pub subject: Sub,

    /// Command of the delegation (similar to a function name).
    pub command: Cmd,

    /// Policy of the delegation.
    ///
    /// A list of predicates that the [`Invocation`] arguments must satisfy.
    pub policy: Vec<Predicate>,

    /// Expiration time of the delegation.
    pub expiration: Option<Timestamp>,

    /// Earliest time a delegation can be used.
    pub not_before: Option<Timestamp>,

    /// Extensible metadata for the delegation.
    pub meta: BTreeMap<String, Ipld>,

    /// Nonce (will be autogenerated if left blank).
    pub nonce: Option<Nonce>,

    _sig: PhantomData<S>,
}

impl<S: Signature> DelegationBuilder<S> {
    /// Creates a blank [`DelegationBuilder`] instance.
    #[must_use]
    pub const fn new() -> Self {
        Self {
            issuer: Unset,
            audience: Unset,
            subject: Unset,
            command: Unset,
            policy: Vec::new(),
            expiration: None,
            not_before: None,
            meta: BTreeMap::new(),
            nonce: None,
            _sig: PhantomData,
        }
    }
}

#[allow(private_bounds)]
impl<
    S: Signature,
    Iss: IssuerOrUnset<S>,
    Audience: DidOrUnset,
    Sub: SubjectOrUnset,
    Cmd: CommandOrUnset,
> DelegationBuilder<S, Iss, Audience, Sub, Cmd>
{
    /// Sets the issuer (signer) of the delegation.
    #[must_use]
    pub fn issuer<I: Issuer<S>>(self, issuer: I) -> DelegationBuilder<S, I, Audience, Sub, Cmd> {
        DelegationBuilder {
            issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: self.nonce,
            _sig: PhantomData,
        }
    }

    /// Sets the `audience` field of the delegation.
    #[must_use]
    pub fn audience(self, audience: &impl Principal) -> DelegationBuilder<S, Iss, Did, Sub, Cmd> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: audience.did(),
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: self.nonce,
            _sig: PhantomData,
        }
    }

    /// Sets the `subject` field of the delegation.
    #[must_use]
    pub fn subject(self, subject: Subject) -> DelegationBuilder<S, Iss, Audience, Subject, Cmd> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: self.nonce,
            _sig: PhantomData,
        }
    }

    /// Sets the `command` field of the delegation.
    #[must_use]
    pub fn command(
        self,
        command: Vec<String>,
    ) -> DelegationBuilder<S, Iss, Audience, Sub, Command> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: Command::new(command),
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: self.nonce,
            _sig: PhantomData,
        }
    }

    /// Sets the `policy` field of the delegation.
    #[must_use]
    pub fn policy(self, policy: Vec<Predicate>) -> DelegationBuilder<S, Iss, Audience, Sub, Cmd> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: self.nonce,
            _sig: PhantomData,
        }
    }

    /// Sets the `expiration` field of the delegation.
    #[must_use]
    pub fn expiration(
        self,
        expiration: Timestamp,
    ) -> DelegationBuilder<S, Iss, Audience, Sub, Cmd> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: Some(expiration),
            not_before: self.not_before,
            meta: self.meta,
            nonce: self.nonce,
            _sig: PhantomData,
        }
    }

    /// Sets the `not_before` field of the delegation.
    #[must_use]
    pub fn not_before(
        self,
        not_before: Timestamp,
    ) -> DelegationBuilder<S, Iss, Audience, Sub, Cmd> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: Some(not_before),
            meta: self.meta,
            nonce: self.nonce,
            _sig: PhantomData,
        }
    }

    /// Sets the `meta` field of the delegation.
    #[must_use]
    pub fn meta(
        self,
        meta: BTreeMap<String, Ipld>,
    ) -> DelegationBuilder<S, Iss, Audience, Sub, Cmd> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta,
            nonce: self.nonce,
            _sig: PhantomData,
        }
    }

    /// Sets the `nonce` field of the delegation.
    #[must_use]
    pub fn nonce(self, nonce: Nonce) -> DelegationBuilder<S, Iss, Audience, Sub, Cmd> {
        DelegationBuilder {
            issuer: self.issuer,
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: self.meta,
            nonce: Some(nonce),
            _sig: PhantomData,
        }
    }
}

/// Build error type for delegation builder.
#[derive(Debug, thiserror::Error)]
pub enum BuildError {
    /// Encoding error.
    #[error("Encoding error: {0}")]
    EncodingError(String),

    /// Signing error.
    #[error("Signing error: {0}")]
    SigningError(#[from] signature::Error),
}

impl<S: Signature, I: Issuer<S>> DelegationBuilder<S, I, Did, Subject, Command> {
    /// Builds the complete, signed [`Delegation`].
    ///
    /// Uses the issuer (set via `.issuer()`) to sign the delegation.
    /// The signing is performed asynchronously via [`Signer::sign()`][varsig::signature::Signer::sign].
    ///
    /// # Errors
    ///
    /// * [`BuildError::EncodingError`] if encoding the payload fails
    /// * [`BuildError::SigningError`] if signing fails
    ///
    /// # Panics
    ///
    /// Panics if random number generator fails when generating a nonce.
    /// This will never happen if a nonce is provided, and is not recoverable
    /// because a broken RNG is a serious problem.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let delegation = DelegationBuilder::new()
    ///     .issuer(signer)
    ///     .audience(&audience_did)
    ///     .subject(Subject::Any)
    ///     .command(vec!["storage".into(), "read".into()])
    ///     .try_build()
    ///     .await?;
    /// ```
    #[allow(clippy::expect_used)]
    pub async fn try_build(self) -> Result<super::Delegation<S>, BuildError> {
        let payload = super::DelegationPayload {
            issuer: self.issuer.did(),
            audience: self.audience,
            subject: self.subject,
            command: self.command,
            policy: self.policy,
            expiration: self.expiration,
            not_before: self.not_before,
            meta: if self.meta.is_empty() {
                None
            } else {
                Some(self.meta)
            },
            nonce: self
                .nonce
                .unwrap_or_else(|| Nonce::generate_16().expect("failed to generate nonce")),
        };

        let envelope = EnvelopePayload::from(payload);

        let encoded = envelope
            .encode()
            .map_err(|e| BuildError::EncodingError(e.to_string()))?;

        let signature = varsig::signature::Signer::sign(&self.issuer, &encoded)
            .await
            .map_err(BuildError::SigningError)?;

        Ok(super::Delegation(Envelope(signature, envelope)))
    }
}
