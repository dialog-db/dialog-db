//! Example implementation of a Person rule match that implements Predicate
//!
//! This demonstrates how generated rule Match types should implement Predicate
//! to enable direct querying like `dialog.query(john)`.

use crate::error::QueryResult;
use crate::join::FactSelectorJoinPlan;
use crate::plan::{EvaluationContext, EvaluationPlan, Plan};
use crate::predicate::Predicate;
use crate::query::Query;
use crate::selection::Selection;
use crate::syntax::VariableScope;
use crate::term::Term;
use dialog_artifacts::{Artifact, ArtifactStore, DialogArtifactsError, Entity, Value};
use futures_util::Stream;

/// Example Person rule match (would be generated by macro)
#[derive(Debug, Clone)]
pub struct PersonMatch {
    pub this: Term<Entity>,
    pub name: Term<String>,
    pub birthday: Term<u32>,
}

/// Implementation of Predicate for PersonMatch
impl Predicate for PersonMatch {
    type Plan = PersonMatchPlan;

    fn plan(&self, _scope: &VariableScope) -> QueryResult<Self::Plan> {
        // Convert typed terms to Value terms
        let name_value_term = match &self.name {
            Term::Constant(s) => Term::Constant(Value::String(s.clone())),
            Term::Variable { name, .. } => Term::Variable {
                name: name.clone(),
                _type: Default::default(),
            },
        };

        let birthday_value_term = match &self.birthday {
            Term::Constant(b) => Term::Constant(Value::UnsignedInt((*b).into())),
            Term::Variable { name, .. } => Term::Variable {
                name: name.clone(),
                _type: Default::default(),
            },
        };

        // Create attributes to join
        let attributes = vec![
            ("person/name".to_string(), name_value_term),
            ("person/birthday".to_string(), birthday_value_term),
        ];

        // Create join plan for all attributes
        let join_plan = crate::join::create_attribute_join(
            self.this.clone(),
            attributes,
        );

        Ok(PersonMatchPlan {
            person_match: self.clone(),
            join_plan,
        })
    }
}

/// Execution plan for PersonMatch
#[derive(Debug, Clone)]
pub struct PersonMatchPlan {
    pub person_match: PersonMatch,
    pub join_plan: FactSelectorJoinPlan,
}

impl Plan for PersonMatchPlan {}

impl EvaluationPlan for PersonMatchPlan {
    fn cost(&self) -> f64 {
        self.join_plan.cost()
    }

    fn evaluate<S, M>(&self, context: EvaluationContext<S, M>) -> impl Selection + '_
    where
        S: ArtifactStore + Clone + Send + 'static,
        M: Selection + 'static,
    {
        // Delegate to the join plan which handles:
        // 1. Evaluating each attribute selector
        // 2. Joining results on the entity variable
        // 3. Returning matches where all attributes exist
        self.join_plan.evaluate(context)
    }
}

/// Implementation of Query trait for PersonMatch
/// This enables direct querying: `dialog.query(john)`
impl Query for PersonMatch {
    fn query<S>(
        &self,
        store: &S,
    ) -> QueryResult<impl Stream<Item = Result<Artifact, DialogArtifactsError>> + 'static>
    where
        S: ArtifactStore,
    {
        // For fully bound queries (no variables), we can optimize
        if let (Term::Constant(entity), Term::Constant(name), Term::Constant(birthday)) =
            (&self.this, &self.name, &self.birthday)
        {
            // Query for both facts and ensure they exist
            let name_attr = "person/name".parse::<dialog_artifacts::Attribute>().unwrap();
            let birthday_attr = "person/birthday".parse::<dialog_artifacts::Attribute>().unwrap();

            let name_selector = dialog_artifacts::ArtifactSelector::new()
                .the(name_attr.clone())
                .of(entity.clone())
                .is(Value::String(name.clone()));

            let birthday_selector = dialog_artifacts::ArtifactSelector::new()
                .the(birthday_attr.clone())
                .of(entity.clone())
                .is(Value::UnsignedInt((*birthday).into()));

            // Query both facts
            let name_stream = store.select(name_selector);
            let _birthday_stream = store.select(birthday_selector);

            // For simplicity, just return the name facts
            // A full implementation would join and validate both exist
            Ok(name_stream)
        } else {
            // With variables, we need the full evaluation plan
            // For this initial implementation, we don't support variable queries via Query trait
            Err(crate::error::QueryError::VariableNotSupported {
                message: "PersonMatch with variables requires evaluation plan - use predicate system instead".to_string(),
            })
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::Term;
    use dialog_artifacts::Entity;

    #[test]
    fn test_person_match_creation() {
        let person = Term::var("person");
        let john = PersonMatch {
            this: person.clone(),
            name: Term::from("John"),
            birthday: Term::from(1983u32),
        };

        match &john.name {
            Term::Constant(name) => assert_eq!(name, "John"),
            _ => panic!("Expected constant"),
        }

        match &john.birthday {
            Term::Constant(birthday) => assert_eq!(*birthday, 1983u32),
            _ => panic!("Expected constant"),
        }
    }

    #[test]
    fn test_person_match_planning() {
        let entity = Entity::new().unwrap();
        let john = PersonMatch {
            this: Term::from(entity),
            name: Term::from("John"),
            birthday: Term::from(1983u32),
        };

        let scope = VariableScope::new();
        let plan = john.plan(&scope);

        assert!(plan.is_ok());
    }
}