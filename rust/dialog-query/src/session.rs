//! Database sessions and query sessions
//!
//! This module provides two main types:
//! - `Session`: For committing changes and rule-aware querying
//! - `QuerySession`: For read-only rule-aware querying

pub mod transaction;

pub use crate::artifact::{
    Artifact, ArtifactSelector, ArtifactStore, ConditionalSend, ConditionalSync, Constrained,
    DialogArtifactsError,
};
use crate::query::Source;
use crate::session::transaction::{Transaction, TransactionError};
use crate::{DeductiveRule, Store};
use std::collections::HashMap;
use transaction::Edit;

/// Registry for deductive rules, indexed by conclusion operator
///
/// Provides deduplicating rule registration and operator-based lookup.
/// Used internally by both `Session` and `QuerySession`.
#[derive(Debug, Clone, Default)]
pub struct RuleRegistry {
    rules: HashMap<String, Vec<DeductiveRule>>,
}

impl RuleRegistry {
    /// Creates an empty rule registry.
    pub fn new() -> Self {
        Self::default()
    }

    /// Register a deductive rule, deduplicating by equality
    pub fn register(&mut self, rule: DeductiveRule) {
        if let Some(rules) = self.rules.get_mut(&rule.conclusion.operator()) {
            if !rules.contains(&rule) {
                rules.push(rule);
            }
        } else {
            self.rules.insert(rule.conclusion.operator(), vec![rule]);
        }
    }

    /// Resolve rules for the given operator
    pub fn resolve_rules(&self, operator: &str) -> Vec<DeductiveRule> {
        self.rules.get(operator).cloned().unwrap_or_default()
    }

    /// Get a reference to all rules
    pub fn rules(&self) -> &HashMap<String, Vec<DeductiveRule>> {
        &self.rules
    }
}

/// A database session for committing changes
///
/// Sessions provide a high-level interface for committing claims to the database.
/// Accepts various input types like `Vec<Claim>`, single claims, or `Claims` collections.
///
/// # Examples
///
/// ```no_run
/// # use dialog_query::{Session, Attribute, Entity, attribute::With};
/// #[derive(Attribute, Clone)]
/// #[namespace(user)]
/// struct Name(String);
///
/// # async fn example(store: impl dialog_query::Store) -> Result<(), Box<dyn std::error::Error>> {
/// let entity = Entity::new()?;
/// let mut session = Session::open(store);
///
/// // Commit changes using a transaction
/// let mut edit = session.edit();
/// edit.assert(With { this: entity, has: Name("Alice".to_string()) });
/// session.commit(edit).await?;
/// # Ok(())
/// # }
/// ```
#[derive(Debug, Clone)]
pub struct Session<S: Store> {
    /// The underlying store for database operations
    store: S,
    /// Registry of the rules
    rules: RuleRegistry,
}

impl<S: Store> Session<S> {
    /// Open a new session with the provided store
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use dialog_query::Session;
    /// # fn example(artifacts_store: impl dialog_query::Store) {
    /// let session = Session::open(artifacts_store);
    /// # }
    /// ```
    pub fn open(store: S) -> Self {
        Session {
            store,
            rules: RuleRegistry::new(),
        }
    }

    /// Register a new rule into the session
    pub fn register(mut self, rule: DeductiveRule) -> Self {
        self.rules.register(rule);
        self
    }

    /// Install a rule from a function - concept inferred from function parameter.
    ///
    /// # Example
    ///
    /// ```rs
    /// use dialog_query::{Session, When};
    /// use dialog_query::dsl::Match;
    ///
    /// // Given a concept `Person` with Match<Person> generated by derive macro:
    /// fn person_rule(person: Match<Person>) -> impl When {
    ///     (
    ///         Match::<Person> {
    ///             this: person.this,
    ///             name: person.name,
    ///             age: person.age,
    ///         },
    ///     )
    /// }
    ///
    /// let session = session.install(person_rule)?;
    /// ```
    pub fn install<M, W>(self, rule: impl Fn(M) -> W) -> Result<Self, crate::error::CompileError>
    where
        M: crate::concept::ConceptQuery,
        W: crate::rule::When,
    {
        let query = M::default();
        let concept = query.to_concept();
        let when = rule(query).into_premises();
        let premises = when.into_vec();
        let rule = crate::predicate::DeductiveRule::new(concept, premises)?;
        Ok(self.register(rule))
    }

    /// Create a new transaction for imperative API usage
    ///
    /// Returns a Transaction that can be used to batch operations before committing.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use dialog_query::{Session, Attribute, Entity, attribute::With};
    /// # #[derive(Attribute, Clone)]
    /// # #[namespace(user)]
    /// # struct Name(String);
    /// # async fn example(store: impl dialog_query::Store) -> Result<(), Box<dyn std::error::Error>> {
    /// let entity = Entity::new()?;
    /// let mut session = Session::open(store);
    /// let mut transaction = session.edit();
    ///
    /// // Add operations to the transaction
    /// transaction.assert(With { this: entity, has: Name("Alice".to_string()) });
    ///
    /// // Commit the transaction
    /// session.commit(transaction).await?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn edit(&self) -> Transaction {
        Transaction::new()
    }

    /// Commit a transaction to the database
    ///
    /// Takes ownership of a Transaction and commits all its operations.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use dialog_query::{Session, Attribute, Entity, attribute::With};
    /// # #[derive(Attribute, Clone)]
    /// # #[namespace(user)]
    /// # struct Name(String);
    /// # async fn example(store: impl dialog_query::Store) -> Result<(), Box<dyn std::error::Error>> {
    /// let entity = Entity::new()?;
    /// let mut session = Session::open(store);
    /// let mut edit = session.edit();
    ///
    /// edit.assert(With { this: entity, has: Name("Alice".to_string()) });
    /// session.commit(edit).await?;
    /// # Ok(())
    /// # }
    /// ```
    pub async fn commit(&mut self, transaction: Transaction) -> Result<(), TransactionError> {
        self.store.commit(transaction.into_stream()).await?;
        Ok(())
    }

    /// Legacy method - converts claims to instructions directly
    ///
    /// Accepts `Vec<Claim>`, single claims, or `Claims` collections.
    /// This method is kept for backwards compatibility.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use dialog_query::{Session, Attribute, Entity, attribute::With};
    /// # #[derive(Attribute, Clone)]
    /// # #[namespace(user)]
    /// # struct Name(String);
    /// # async fn example(store: impl dialog_query::Store) -> Result<(), Box<dyn std::error::Error>> {
    /// let alice = Entity::new()?;
    /// let bob = Entity::new()?;
    /// let mut session = Session::open(store);
    ///
    /// // Can pass any items that implement Edit
    /// session.transact([
    ///     With { this: alice, has: Name("Alice".to_string()) },
    ///     With { this: bob, has: Name("Bob".to_string()) },
    /// ]).await?;
    /// # Ok(())
    /// # }
    /// ```
    pub async fn transact<E, D>(&mut self, changes: D) -> Result<(), DialogArtifactsError>
    where
        E: Edit,
        D: IntoIterator<Item = E>,
    {
        let mut transaction = self.edit();
        // Go over each change and merge it into the transaction
        for change in changes {
            change.merge(&mut transaction);
        }

        // commit transaction.
        self.store.commit(transaction.into_stream()).await?;
        Ok(())
    }
}

/// A read-only query session that provides rule-aware querying capabilities
///
/// QuerySession is a lighter-weight alternative to Session that focuses purely on querying
/// with rule resolution support. It can be created from any ArtifactStore and provides
/// an explicit way to enable rule-based inference during queries.
///
/// # Examples
///
/// ```no_run
/// # use dialog_query::{QuerySession, DeductiveRule};
/// # use dialog_query::session::ArtifactStore;
/// # fn example(artifacts: impl ArtifactStore + Clone + Send + Sync + 'static, adult_rule: DeductiveRule) {
/// // Convert an artifact store to a query session
/// let query_session: QuerySession<_> = artifacts.into();
///
/// // Install rules for more advanced querying
/// let query_session = query_session.install(adult_rule);
/// # }
/// ```
#[derive(Debug, Clone)]
pub struct QuerySession<S: ArtifactStore> {
    /// The underlying store for read operations
    store: S,
    /// Registry of the rules for inference
    rules: RuleRegistry,
}

impl<S: ArtifactStore> QuerySession<S> {
    /// Create a new query session wrapping the provided store
    ///
    /// The query session starts with no rules and can have rules installed later.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use dialog_query::QuerySession;
    /// # use dialog_query::session::ArtifactStore;
    /// # fn example(artifacts: impl ArtifactStore) {
    /// let query_session = QuerySession::new(artifacts);
    /// # }
    /// ```
    pub fn new(store: S) -> Self {
        Self {
            store,
            rules: RuleRegistry::new(),
        }
    }

    /// Install a deductive rule into the query session
    ///
    /// Rules are indexed by their conclusion operator and can be used during
    /// query evaluation to derive facts that aren't directly stored.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use dialog_query::{QuerySession, DeductiveRule};
    /// # use dialog_query::session::ArtifactStore;
    /// # fn example(artifacts: impl ArtifactStore, adult_rule: DeductiveRule, senior_rule: DeductiveRule) {
    /// let query_session = QuerySession::new(artifacts)
    ///     .install(adult_rule)
    ///     .install(senior_rule);
    /// # }
    /// ```
    pub fn install(mut self, rule: DeductiveRule) -> Self {
        self.rules.register(rule);
        self
    }

    /// Get a reference to the underlying store
    pub fn store(&self) -> &S {
        &self.store
    }

    /// Get a reference to the rules registry
    pub fn rules(&self) -> &HashMap<String, Vec<DeductiveRule>> {
        self.rules.rules()
    }
}

/// Create QuerySession from any ArtifactStore
impl<S: ArtifactStore + Clone + Send + Sync + 'static> From<S> for QuerySession<S> {
    fn from(store: S) -> Self {
        Self::new(store)
    }
}

/// Implement Source trait for QuerySession to provide rule resolution capabilities
impl<S: ArtifactStore + Clone + Send + Sync + 'static> Source for QuerySession<S> {
    fn resolve_rules(&self, operator: &str) -> Vec<DeductiveRule> {
        self.rules.resolve_rules(operator)
    }
}

/// Forward ArtifactStore methods to the wrapped store
impl<S: ArtifactStore> ArtifactStore for QuerySession<S> {
    fn select(
        &self,
        artifact_selector: ArtifactSelector<Constrained>,
    ) -> impl futures_core::Stream<Item = Result<Artifact, DialogArtifactsError>>
    + ConditionalSend
    + 'static {
        self.store.select(artifact_selector)
    }
}

/// Implement Source trait for Session to provide rule resolution capabilities
///
/// This implementation allows Session to be used directly with the Query trait
/// while providing access to both stored artifacts and registered rules.
impl<S: Store + ConditionalSend + ConditionalSync + 'static> Source for Session<S> {
    fn resolve_rules(&self, operator: &str) -> Vec<DeductiveRule> {
        self.rules.resolve_rules(operator)
    }
}

/// Forward ArtifactStore methods to the wrapped store
impl<S: Store> ArtifactStore for Session<S> {
    fn select(
        &self,
        artifact_selector: ArtifactSelector<Constrained>,
    ) -> impl futures_core::Stream<Item = Result<Artifact, DialogArtifactsError>>
    + ConditionalSend
    + 'static {
        self.store.select(artifact_selector)
    }
}

#[cfg(test)]
mod tests {
    // Allow the derive macro to reference dialog_query:: from within the crate
    extern crate self as dialog_query;

    use std::collections::HashMap;

    use crate::{
        AttributeSchema, Parameters, Relation, Type,
        predicate::{self, FactSelector, concept::Attributes},
    };

    use super::*;

    #[dialog_common::test]
    async fn test_session() -> anyhow::Result<()> {
        use crate::Term;
        use crate::artifact::{Artifacts, Attribute as ArtifactAttribute, Entity, Value};
        use dialog_storage::MemoryStorageBackend;

        let backend = MemoryStorageBackend::default();
        let store = Artifacts::anonymous(backend).await?;
        let mut session = Session::open(store);
        let alice = Entity::new()?;
        let bob = Entity::new()?;
        let mallory = Entity::new()?;

        session
            .transact(vec![
                Relation {
                    the: "person/name".parse::<ArtifactAttribute>()?,
                    of: alice.clone(),
                    is: Value::String("Alice".to_string()),
                },
                Relation {
                    the: "person/age".parse::<ArtifactAttribute>()?,
                    of: alice.clone(),
                    is: Value::UnsignedInt(25),
                },
                Relation {
                    the: "person/name".parse::<ArtifactAttribute>()?,
                    of: bob.clone(),
                    is: Value::String("Bob".to_string()),
                },
                Relation {
                    the: "person/age".parse::<ArtifactAttribute>()?,
                    of: bob.clone(),
                    is: Value::UnsignedInt(30),
                },
                Relation {
                    the: "person/name".parse::<ArtifactAttribute>()?,
                    of: mallory.clone(),
                    is: Value::String("Mallory".to_string()),
                },
            ])
            .await?;

        let person = predicate::ConceptDescriptor::Dynamic {
            description: String::new(),
            attributes: [
                (
                    "name",
                    AttributeSchema::<Value>::new("person", "name", "person name", Type::String),
                ),
                (
                    "age",
                    AttributeSchema::<Value>::new("person", "age", "person age", Type::UnsignedInt),
                ),
            ]
            .into(),
        };

        let name = Term::var("name");
        let age = Term::var("age");
        let mut params = Parameters::new();
        params.insert("name".into(), name.clone());
        params.insert("age".into(), age.clone());

        // Use new query API directly on application
        let application = person.apply(params)?;

        let selection =
            futures_util::TryStreamExt::try_collect::<Vec<_>>(application.query(&session)).await?;
        assert_eq!(selection.len(), 2); // Should find just Alice and Bob

        // Check that we have both Alice and Bob (order may vary)
        let mut found_alice = false;
        let mut found_bob = false;

        for match_result in selection.iter() {
            let person_name = match_result.resolve(&name)?;
            let person_age = match_result.resolve(&age)?;

            match person_name {
                Value::String(name_str) if name_str == "Alice" => {
                    assert_eq!(person_age, Value::UnsignedInt(25));
                    found_alice = true;
                }
                Value::String(name_str) if name_str == "Bob" => {
                    assert_eq!(person_age, Value::UnsignedInt(30));
                    found_bob = true;
                }
                _ => panic!("Unexpected person: {:?}", person_name),
            }
        }

        assert!(found_alice, "Should find Alice");
        assert!(found_bob, "Should find Bob");

        Ok(())
    }

    #[dialog_common::test]
    async fn test_concept_planning_mixed_parameters() -> anyhow::Result<()> {
        use crate::Term;
        use crate::artifact::Type;

        // Set up concept with attributes
        let mut attributes = HashMap::new();
        attributes.insert(
            "name".into(),
            AttributeSchema::new("person", "name", "person name", Type::String),
        );
        attributes.insert(
            "age".into(),
            AttributeSchema::new("person", "age", "person age", Type::UnsignedInt),
        );

        let person = predicate::ConceptDescriptor::Dynamic {
            description: String::new(),
            attributes: Attributes::from(attributes),
        };

        // Mixed case - valid parameters with some matching attributes (should succeed)
        let mut mixed_params = Parameters::new();
        mixed_params.insert("name".into(), Term::var("person_name")); // This matches
        mixed_params.insert("age".into(), Term::blank()); // This matches but is blank

        person.apply(mixed_params)?;

        Ok(())
    }

    #[dialog_common::test]
    async fn test_assert_concept() -> anyhow::Result<()> {
        use crate::Term;
        use crate::artifact::{Artifacts, Value};
        use dialog_storage::MemoryStorageBackend;

        let backend = MemoryStorageBackend::default();
        let store = Artifacts::anonymous(backend).await?;
        let mut session = Session::open(store);

        let person = predicate::ConceptDescriptor::Dynamic {
            description: String::new(),
            attributes: [
                (
                    "name",
                    AttributeSchema::new("person", "name", "person name", Type::String),
                ),
                (
                    "age",
                    AttributeSchema::new("person", "age", "person age", Type::UnsignedInt),
                ),
            ]
            .into(),
        };

        let alice = person
            .create()
            .with("name", "Alice".to_string())
            .with("age", 25usize)
            .build()?;

        let bob = person
            .create()
            .with("name", "Bob".to_string())
            .with("age", 30usize)
            .build()?;

        session.transact(vec![alice, bob]).await?;

        let name = Term::var("name");
        let age = Term::var("age");
        let mut params = Parameters::new();
        params.insert("name".into(), name.clone());
        params.insert("age".into(), age.clone());

        // Let's test with empty parameters first to see the exact error
        let application = person.apply(params)?;

        let selection =
            futures_util::TryStreamExt::try_collect::<Vec<_>>(application.query(&session)).await?;
        assert_eq!(selection.len(), 2); // Should find just Alice and Bob

        // Check that we have both Alice and Bob (order may vary)
        let mut found_alice = false;
        let mut found_bob = false;

        for match_result in selection.iter() {
            let person_name = match_result.resolve(&name)?;
            let person_age = match_result.resolve(&age)?;

            match person_name {
                Value::String(name_str) if name_str == "Alice" => {
                    assert_eq!(person_age, Value::UnsignedInt(25));
                    found_alice = true;
                }
                Value::String(name_str) if name_str == "Bob" => {
                    assert_eq!(person_age, Value::UnsignedInt(30));
                    found_bob = true;
                }
                _ => panic!("Unexpected person: {:?}", person_name),
            }
        }

        assert!(found_alice, "Should find Alice");
        assert!(found_bob, "Should find Bob");

        Ok(())
    }

    #[dialog_common::test]
    async fn test_rule() -> anyhow::Result<()> {
        use crate::artifact::{Artifacts, Entity};
        use crate::query::Output;
        use crate::rule::Match;
        use crate::{Concept, Fact, Term};
        use dialog_storage::MemoryStorageBackend;

        mod employee {
            use crate::Attribute;

            #[derive(Attribute, Clone, PartialEq)]
            pub struct Name(pub String);

            #[derive(Attribute, Clone, PartialEq)]
            pub struct Job(pub String);
        }

        mod stuff {
            use crate::Attribute;

            #[derive(Attribute, Clone, PartialEq)]
            pub struct Name(pub String);

            #[derive(Attribute, Clone, PartialEq)]
            pub struct Role(pub String);
        }

        #[derive(Clone, Debug, PartialEq, Concept)]
        pub struct Employee {
            /// Employee
            pub this: Entity,
            /// Employee Name
            pub name: employee::Name,
            /// The job title of the employee
            pub job: employee::Job,
        }

        #[derive(Clone, Debug, PartialEq, Concept)]
        pub struct Stuff {
            pub this: Entity,
            /// Name of the stuff member
            pub name: stuff::Name,
            /// Role of the stuff member
            pub role: stuff::Role,
        }

        // employee can be derived from the stuff concept
        let employee_from_stuff = DeductiveRule::new(
            <Employee as Concept>::CONCEPT,
            vec![
                Fact::<String>::select()
                    .the("stuff/name")
                    .of(Term::var("this"))
                    .is(Term::var("name"))
                    .compile()?
                    .into(),
                Fact::<String>::select()
                    .the("stuff/role")
                    .of(Term::var("this"))
                    .is(Term::var("job"))
                    .compile()?
                    .into(),
            ],
        )?;

        let backend = MemoryStorageBackend::default();
        let store = Artifacts::anonymous(backend).await?;
        let mut session = Session::open(store).register(employee_from_stuff);

        let alice = Stuff::CONCEPT
            .create()
            .with("name", "Alice".to_string())
            .with("role", "manager".to_string())
            .build()?;

        let bob = Stuff::CONCEPT
            .create()
            .with("name", "Bob".to_string())
            .with("role", "developer".to_string())
            .build()?;

        let _mallory = Stuff {
            this: Entity::new()?,
            name: stuff::Name("Mallory".into()),
            role: stuff::Role("developer".into()),
        };

        session.transact(vec![alice, bob]).await?;

        let query_stuff = Match::<Stuff> {
            this: Term::var("stuff"),
            name: Term::var("name"),
            role: Term::var("job"),
        };

        let stuff = query_stuff.query(session.clone()).try_vec().await?;

        assert_eq!(stuff.len(), 2);

        // Now we query for employees and expect that employee_from_stuff
        // rule will provide a translation
        let query_employee = Match::<Employee> {
            this: Term::var("employee"),
            name: Term::var("name"),
            job: Term::var("job"),
        };

        let employees = Output::try_vec(query_employee.query(session)).await?;

        assert_eq!(employees.len(), 2);
        println!("{:?}", employees);

        Ok(())
    }

    #[dialog_common::test]
    async fn test_install_rule_api() -> anyhow::Result<()> {
        use crate::artifact::{Artifacts, Entity};
        use crate::query::Output;
        use crate::rule::When;
        use crate::{Concept, Match, Term};
        use dialog_storage::MemoryStorageBackend;

        mod employee {
            use crate::Attribute;

            #[derive(Attribute, Clone, PartialEq)]
            pub struct Name(pub String);

            #[derive(Attribute, Clone, PartialEq)]
            pub struct Job(pub String);
        }

        mod stuff {
            use crate::Attribute;

            #[derive(Attribute, Clone, PartialEq)]
            pub struct Name(pub String);

            #[derive(Attribute, Clone, PartialEq)]
            pub struct Role(pub String);
        }

        #[derive(Clone, Debug, PartialEq, Concept)]
        pub struct Employee {
            /// Employee
            pub this: Entity,
            /// Employee Name
            pub name: employee::Name,
            /// The job title of the employee
            pub job: employee::Job,
        }

        #[derive(Clone, Debug, PartialEq, Concept)]
        pub struct Stuff {
            pub this: Entity,
            /// Name of the stuff member
            pub name: stuff::Name,
            /// Role of the stuff member
            pub role: stuff::Role,
        }

        // Define a rule using the clean function API - no manual DeductiveRule construction!
        fn employee_from_stuff(employee: Match<Employee>) -> impl When {
            // This rule says: "An employee exists when there's stuff with matching attributes"
            // The premises check for stuff/name and stuff/role matching employee/name and employee/job
            (
                Match::<Stuff> {
                    this: employee.this.clone(),
                    name: employee.name.clone(),
                    role: employee.job,
                },
                FactSelector {
                    the: "stuff/name"
                        .parse::<crate::artifact::Attribute>()
                        .unwrap()
                        .into(),
                    of: employee.this,
                    is: employee.name.as_unknown(),
                    cause: Term::blank(),
                }
                .compile()
                .unwrap(),
            )
        }

        let backend = MemoryStorageBackend::default();
        let store = Artifacts::anonymous(backend).await?;

        // Install the rule using the clean API - no turbofish needed!
        // The type inference works: Employee is inferred from the function parameter
        let mut session = Session::open(store).install(employee_from_stuff)?;

        // Create test data as Stuff
        let alice = Stuff::CONCEPT
            .create()
            .with("name", "Alice".to_string())
            .with("role", "manager".to_string())
            .build()?;

        let bob = Stuff::CONCEPT
            .create()
            .with("name", "Bob".to_string())
            .with("role", "developer".to_string())
            .build()?;

        session.transact(vec![alice, bob]).await?;

        // Verify Stuff records exist
        let query_stuff = Match::<Stuff> {
            this: Term::var("stuff"),
            name: Term::var("name"),
            role: Term::var("job"),
        };

        let stuff = query_stuff.query(session.clone()).try_vec().await?;
        assert_eq!(stuff.len(), 2, "Should have 2 Stuff records");

        // Query for Employees - the rule should derive them from Stuff
        let query_employee = Match::<Employee> {
            this: Term::var("employee"),
            name: Term::var("name"),
            job: Term::var("job"),
        };

        let employees = Output::try_vec(query_employee.query(session)).await?;

        // The rule should have derived 2 Employee instances from the 2 Stuff instances
        assert_eq!(
            employees.len(),
            2,
            "Rule should derive 2 employees from stuff"
        );

        // Verify the derived data is correct
        let mut found_alice = false;
        let mut found_bob = false;

        for employee in employees {
            use crate::Attribute as _;
            match employee.name.value().as_str() {
                "Alice" => {
                    assert_eq!(employee.job.value(), "manager");
                    found_alice = true;
                }
                "Bob" => {
                    assert_eq!(employee.job.value(), "developer");
                    found_bob = true;
                }
                name => panic!("Unexpected employee: {}", name),
            }
        }

        assert!(found_alice, "Should find Alice as an employee");
        assert!(found_bob, "Should find Bob as an employee");

        Ok(())
    }

    #[dialog_common::test]
    async fn test_session_source_rule_resolution() -> anyhow::Result<()> {
        use crate::artifact::Artifacts;
        use crate::predicate::concept::Attributes;
        use crate::query::Source;
        use dialog_storage::MemoryStorageBackend;

        // Setup: Create a Session with a rule-aware store
        let backend = MemoryStorageBackend::default();
        let artifacts = Artifacts::anonymous(backend).await?;
        let session = Session::open(artifacts);

        // Test 1: Verify Session implements Source trait
        assert_eq!(session.resolve_rules("nonexistent"), Vec::new());

        // Test 2: Install a rule and verify it can be resolved
        let adult_conclusion = predicate::ConceptDescriptor::Dynamic {
            description: String::new(),
            attributes: Attributes::from(vec![
                (
                    "name",
                    AttributeSchema::new("adult", "name", "Adult name", Type::String),
                ),
                (
                    "age",
                    AttributeSchema::new("adult", "age", "Adult age", Type::UnsignedInt),
                ),
            ]),
        };

        // Create a simple rule: adult(X, Age) :- person(X, Age), Age >= 18
        let rule = DeductiveRule {
            conclusion: adult_conclusion.clone(),
            premises: vec![],
        };

        let session_with_rule = session.register(rule.clone());

        // Test 3: Verify the rule can be resolved
        let adult_operator = adult_conclusion.operator();
        let resolved_rules = session_with_rule.resolve_rules(&adult_operator);
        assert_eq!(resolved_rules.len(), 1);
        assert_eq!(resolved_rules[0].conclusion.operator(), adult_operator);

        // Test 4: Verify non-matching operator returns empty
        assert_eq!(session_with_rule.resolve_rules("nonexistent"), Vec::new());

        Ok(())
    }

    #[dialog_common::test]
    async fn test_source_trait_compatibility() -> anyhow::Result<()> {
        use crate::artifact::Artifacts;
        use crate::predicate::concept::Attributes;
        use crate::query::Source;
        use dialog_storage::MemoryStorageBackend;

        // Test that both QuerySession and Session can be used polymorphically as a Source
        async fn query_with_source<S: Source>(source: &S, operator: &str) -> Vec<DeductiveRule> {
            source.resolve_rules(operator)
        }

        let backend = MemoryStorageBackend::default();
        let artifacts = Artifacts::anonymous(backend).await?;

        // Test with QuerySession
        let query_session: QuerySession<_> = artifacts.clone().into();
        let concept = predicate::ConceptDescriptor::new(Attributes::new());
        let rule = DeductiveRule {
            conclusion: concept.clone(),
            premises: vec![],
        };

        let query_session = query_session.install(rule.clone());
        // Query using the concept's actual operator (hash URI)
        let operator = concept.operator();
        let rules = query_with_source(&query_session, &operator).await;
        assert_eq!(rules.len(), 1);
        assert_eq!(rules[0].conclusion.operator(), concept.operator());

        // Test with Session
        let mut session = Session::open(artifacts);
        session = session.register(rule.clone());
        let rules = query_with_source(&session, &operator).await;
        assert_eq!(rules.len(), 1);
        assert_eq!(rules[0].conclusion.operator(), concept.operator());

        Ok(())
    }

    #[dialog_common::test]
    async fn test_multiple_rules_same_operator() -> anyhow::Result<()> {
        use crate::artifact::Artifacts;
        use crate::predicate::concept::Attributes;
        use crate::query::Source;
        use dialog_storage::MemoryStorageBackend;

        // Test that multiple rules for the same operator are stored and resolved correctly
        let backend = MemoryStorageBackend::default();
        let artifacts = Artifacts::anonymous(backend).await?;

        // Test with QuerySession
        let query_session: QuerySession<_> = artifacts.into();

        // Create two different rules for the same concept (same attributes = same hash)
        let attributes: Attributes = [(
            "name".to_string(),
            AttributeSchema::new("person", "name", "Person name", Type::String),
        )]
        .into();

        let concept1 = predicate::ConceptDescriptor::Dynamic {
            description: "First rule".to_string(),
            attributes: attributes.clone(),
        };

        let concept2 = predicate::ConceptDescriptor::Dynamic {
            description: "Second rule".to_string(),
            attributes,
        };

        let rule1 = DeductiveRule {
            conclusion: concept1.clone(),
            premises: vec![],
        };

        let rule2 = DeductiveRule {
            conclusion: concept2.clone(),
            premises: vec![],
        };

        // Install both rules
        let query_session = query_session.install(rule1).install(rule2);

        // Should resolve both rules for the same concept operator (hash)
        let operator = concept1.operator();
        let rules = query_session.resolve_rules(&operator);
        assert_eq!(rules.len(), 2, "Should have 2 rules for the same concept");

        // Both rules should have the same operator (hash)
        for rule in &rules {
            assert_eq!(rule.conclusion.operator(), operator);
        }

        Ok(())
    }

    #[dialog_common::test]
    async fn test_explicit_conversion_pattern() -> anyhow::Result<()> {
        use crate::artifact::Artifacts;
        use crate::query::Source;
        use dialog_storage::MemoryStorageBackend;

        // Test the explicit conversion pattern: artifacts.into() for QuerySession
        let backend = MemoryStorageBackend::default();
        let artifacts = Artifacts::anonymous(backend).await?;

        // Test 1: Basic conversion - no rules
        let query_session: QuerySession<_> = artifacts.clone().into();
        assert_eq!(query_session.resolve_rules("nonexistent"), Vec::new());
        assert_eq!(query_session.rules().len(), 0);

        // Test 2: Conversion with rule installation
        let adult_concept = predicate::ConceptDescriptor::Dynamic {
            description: String::new(),
            attributes: [(
                "name".to_string(),
                AttributeSchema::new("person", "name", "Adult name", Type::String),
            )]
            .into(),
        };

        let adult_rule = DeductiveRule {
            conclusion: adult_concept.clone(),
            premises: vec![],
        };

        let query_session: QuerySession<_> = artifacts.into();
        let query_session = query_session.install(adult_rule.clone());

        let adult_operator = adult_concept.operator();
        let resolved_rules = query_session.resolve_rules(&adult_operator);
        assert_eq!(resolved_rules.len(), 1);
        assert_eq!(resolved_rules[0].conclusion.operator(), adult_operator);

        // Test 3: Verify store is still accessible
        assert!(!std::ptr::addr_of!(*query_session.store()).is_null());

        Ok(())
    }

    mod implicit_attr_test {
        use crate::Attribute;

        #[derive(Attribute, Clone, PartialEq)]
        pub struct Name(pub String);

        #[derive(Attribute, Clone, PartialEq)]
        pub struct Role(pub String);
    }

    #[dialog_common::test]
    async fn test_like_formula_in_rule() -> anyhow::Result<()> {
        use crate::artifact::{Artifacts, Entity};
        use crate::formula::Like;
        use crate::query::Output;
        use crate::rule::When;
        use crate::{Attribute, Concept, Match, Term};
        use dialog_storage::MemoryStorageBackend;

        mod note_like_test {
            use crate::Attribute;

            #[derive(Attribute, Clone, PartialEq)]
            pub struct Title(pub String);

            #[derive(Attribute, Clone, PartialEq)]
            pub struct MatchedTitle(pub String);
        }

        #[derive(Clone, Debug, PartialEq, Concept)]
        pub struct Note {
            pub this: Entity,
            pub title: note_like_test::Title,
        }

        #[derive(Clone, Debug, PartialEq, Concept)]
        pub struct MatchingNote {
            pub this: Entity,
            pub title: note_like_test::MatchedTitle,
        }

        // Rule: a MatchingNote is a Note whose title matches "Hello*"
        fn matching_notes(result: Match<MatchingNote>) -> impl When {
            let title = Term::<String>::var("_title");
            (
                Match::<Note> {
                    this: result.this,
                    title: title.clone(),
                },
                Match::<Like> {
                    text: title,
                    pattern: Term::from("Hello*".to_string()),
                    is: result.title,
                },
            )
        }

        let backend = MemoryStorageBackend::default();
        let store = Artifacts::anonymous(backend).await?;
        let mut session = Session::open(store).install(matching_notes)?;

        let mut transaction = session.edit();
        transaction.assert(Note {
            this: Entity::new()?,
            title: note_like_test::Title("Hello World".into()),
        });
        transaction.assert(Note {
            this: Entity::new()?,
            title: note_like_test::Title("Hello Rust".into()),
        });
        transaction.assert(Note {
            this: Entity::new()?,
            title: note_like_test::Title("Goodbye World".into()),
        });
        session.commit(transaction).await?;

        let results = Match::<MatchingNote> {
            this: Term::var("note"),
            title: Term::var("title"),
        }
        .query(session)
        .try_vec()
        .await?;

        assert_eq!(results.len(), 2, "Should match only the two Hello* notes");

        let mut titles: Vec<String> = results.iter().map(|n| n.title.value().clone()).collect();
        titles.sort();
        assert_eq!(titles, vec!["Hello Rust", "Hello World"]);

        Ok(())
    }

    #[dialog_common::test]
    async fn test_like_negation_in_rule() -> anyhow::Result<()> {
        use crate::artifact::{Artifacts, Entity};
        use crate::formula::Like;
        use crate::query::Output;
        use crate::rule::When;
        use crate::{Attribute, Concept, Match, Term};
        use dialog_storage::MemoryStorageBackend;

        mod note_not_like_test {
            use crate::Attribute;

            #[derive(Attribute, Clone, PartialEq)]
            pub struct Title(pub String);

            #[derive(Attribute, Clone, PartialEq)]
            pub struct FilteredTitle(pub String);
        }

        #[derive(Clone, Debug, PartialEq, Concept)]
        pub struct Note {
            pub this: Entity,
            pub title: note_not_like_test::Title,
        }

        #[derive(Clone, Debug, PartialEq, Concept)]
        pub struct NonDraftNote {
            pub this: Entity,
            pub title: note_not_like_test::FilteredTitle,
        }

        // Rule: a NonDraftNote is a Note whose title does NOT match "Draft:*"
        fn non_draft_notes(result: Match<NonDraftNote>) -> impl When {
            let title = Term::<String>::var("_title");
            (
                Match::<Note> {
                    this: result.this,
                    title: title.clone(),
                },
                Match::<Like> {
                    text: title.clone(),
                    pattern: Term::from("*".to_string()),
                    is: result.title,
                },
                !Match::<Like> {
                    text: title,
                    pattern: Term::from("Draft:*".to_string()),
                    is: Term::blank(),
                },
            )
        }

        let backend = MemoryStorageBackend::default();
        let store = Artifacts::anonymous(backend).await?;
        let mut session = Session::open(store).install(non_draft_notes)?;

        let mut transaction = session.edit();
        transaction.assert(Note {
            this: Entity::new()?,
            title: note_not_like_test::Title("Draft: My Ideas".into()),
        });
        transaction.assert(Note {
            this: Entity::new()?,
            title: note_not_like_test::Title("Published Article".into()),
        });
        transaction.assert(Note {
            this: Entity::new()?,
            title: note_not_like_test::Title("Draft: TODO".into()),
        });
        transaction.assert(Note {
            this: Entity::new()?,
            title: note_not_like_test::Title("Final Report".into()),
        });
        session.commit(transaction).await?;

        let results = Match::<NonDraftNote> {
            this: Term::var("note"),
            title: Term::var("title"),
        }
        .query(session)
        .try_vec()
        .await?;

        assert_eq!(results.len(), 2, "Should exclude the two Draft:* notes");

        let mut titles: Vec<String> = results.iter().map(|n| n.title.value().clone()).collect();
        titles.sort();
        assert_eq!(titles, vec!["Final Report", "Published Article"]);

        Ok(())
    }

    #[dialog_common::test]
    async fn test_implicit_attribute() -> anyhow::Result<()> {
        use crate::artifact::{Artifacts, Entity};
        use crate::query::Output;
        use crate::rule::When;
        use crate::{Attribute as _, Concept, Fact, Match, Term};
        use dialog_storage::MemoryStorageBackend;
        use implicit_attr_test::{Name, Role};

        #[derive(Clone, Debug, PartialEq, Concept)]
        pub struct Employee {
            /// Employee
            pub this: Entity,
            /// Employee Name
            pub name: Name,
            /// The job title of the employee
            pub role: Role,
        }

        #[derive(Clone, Debug, PartialEq, Concept)]
        pub struct EmployeeWithoutRole {
            /// Employee
            pub this: Entity,
            /// Employee Name
            pub name: Name,
        }

        // Define a rule using the clean function API - no manual DeductiveRule construction!
        fn employee_with_implicit_title(employee: Match<Employee>) -> impl When {
            // This rule says: "An employee exists when there's stuff with matching attributes"
            // The premises check for stuff/name and stuff/role matching employee/name and employee/job
            (
                employee.role.is(Role("employee".into())),
                // employee has a name
                Fact::<String>::select()
                    .the("implicit-attr-test/name")
                    .of(employee.this.clone())
                    .is(employee.name.clone().as_unknown())
                    .compile()
                    .unwrap(),
                // but does not have role (using ! operator)
                !Fact::<String>::select()
                    .the("implicit-attr-test/role")
                    .of(employee.this.clone())
                    .is(Term::blank())
                    .compile()
                    .unwrap(),
            )
        }

        let backend = MemoryStorageBackend::default();
        let store = Artifacts::anonymous(backend).await?;

        // Install the rule using the clean API - no turbofish needed!
        // The type inference works: Employee is inferred from the function parameter
        let mut session = Session::open(store).install(employee_with_implicit_title)?;

        let mut transaction = session.edit();
        transaction.assert(Employee {
            this: Entity::new()?,
            name: Name("Alice".into()),
            role: Role("manager".into()),
        });
        transaction.assert(EmployeeWithoutRole {
            this: Entity::new()?,
            name: Name("Bob".into()),
        });

        // Create test data as Stuff
        session.commit(transaction).await?;

        // Verify Stuff records exist
        let employees = Match::<Employee> {
            this: Term::var("employee"),
            name: Term::var("name"),
            role: Term::var("title"),
        };

        let result = employees.query(session.clone()).try_vec().await?;
        assert_eq!(result.len(), 2, "Should have 2 Stuff records");

        // Verify the derived data is correct
        let mut found_alice = false;
        let mut found_bob = false;

        for employee in result {
            match employee.name.value().as_str() {
                "Alice" => {
                    assert_eq!(employee.role.value(), "manager");
                    found_alice = true;
                }
                "Bob" => {
                    assert_eq!(employee.role.value(), "employee");
                    found_bob = true;
                }
                name => panic!("Unexpected employee: {}", name),
            }
        }

        assert!(found_alice, "Should find Alice as an employee");
        assert!(found_bob, "Should find Bob as an employee");

        Ok(())
    }
}
